package generate

import (
	"bytes"
	"testing"

	sloth "github.com/slok/sloth/pkg/prometheus/api/v1"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestWriteToStdout(t *testing.T) {
	t.Run("successfully write files to stdout", func(t *testing.T) {
		expected := []map[string][]byte{
			{"foobar": []byte("foobar")},
			{"test": []byte(`# Code generated by slotalk: https://github.com/tfadeyi/slotalk.
# DO NOT EDIT.
version: prometheus/v1
service: chatgpt
slos:
    - name: chat-gpt-availability
      description: 95% of logins to the chat-gpt app should be successful.
      objective: 95
      sli:
        events:
            error_query: sum(rate(tenant_failed_login_operations_total{client="chat-gpt"}[{{.window}}])) OR on() vector(0)
            total_query: sum(rate(tenant_login_operations_total{client="chat-gpt"}[{{.window}}]))
      alerting:
        name: ChatGPTAvailability
`)},
		}
		for _, exp := range expected {
			var w = bytes.NewBuffer([]byte{})
			require.NoError(t, write(w, exp))
			for _, body := range exp {
				assert.Equal(t, body, w.Bytes())
			}
		}
	})
}

func TestWriteSpecifications(t *testing.T) {
	t.Run("successfully write the yaml specification to the byte writer", func(t *testing.T) {
		specifications := map[string]any{
			"app1": &sloth.Spec{
				Version: sloth.Version,
				Service: "app1",
				Labels:  nil,
				SLOs:    nil,
			},
			"app2": &sloth.Spec{
				Version: sloth.Version,
				Service: "app2",
				Labels: map[string]string{
					"severity": "critical",
				},
				SLOs: []sloth.SLO{
					{
						Name:        "availability",
						Description: "",
						Objective:   0,
						Labels:      nil,
						SLI:         sloth.SLI{},
						Alerting:    sloth.Alerting{},
					},
				},
			},
		}

		expected := `---

version: prometheus/v1
service: app1
---

version: prometheus/v1
service: app2
labels:
    severity: critical
slos:
    - name: availability
      objective: 0
      sli: {}
      alerting:
        name: ""
`
		expected1 := `---

version: prometheus/v1
service: app2
labels:
    severity: critical
slos:
    - name: availability
      objective: 0
      sli: {}
      alerting:
        name: ""
---

version: prometheus/v1
service: app1
`
		var w = bytes.NewBuffer([]byte{})
		require.NoError(t, WriteSpecifications(w, nil, specifications, false, "", "yaml"))
		if expected != w.String() && expected1 != w.String() {
			t.Errorf("unexpected error when checking results")
		}
	})
	t.Run("fail to write the specification to the byte writer if format selected is invalid", func(t *testing.T) {
		specifications := map[string]any{
			"app1": &sloth.Spec{
				Version: sloth.Version,
				Service: "app1",
				Labels:  nil,
				SLOs:    nil,
			},
			"app2": &sloth.Spec{
				Version: sloth.Version,
				Service: "app2",
				Labels: map[string]string{
					"severity": "critical",
				},
				SLOs: []sloth.SLO{
					{
						Name:        "availability",
						Description: "",
						Objective:   0,
						Labels:      nil,
						SLI:         sloth.SLI{},
						Alerting:    sloth.Alerting{},
					},
				},
			},
		}

		var w = bytes.NewBuffer([]byte{})
		require.ErrorIs(t, WriteSpecifications(w, nil, specifications, false, "", "toml"), ErrUnsupportedFormat)
	})
}

func TestIsValidOutputFormat(t *testing.T) {
	t.Run("Successfully return true if the input format is json", func(t *testing.T) {
		assert.True(t, IsValidOutputFormat("json"))
	})
	t.Run("Successfully return true if the input format is yaml", func(t *testing.T) {
		assert.True(t, IsValidOutputFormat("yaml"))
	})
	t.Run("Successfully return true if the input format is YAML", func(t *testing.T) {
		assert.True(t, IsValidOutputFormat("YAML"))
	})
	t.Run("Successfully return true if the input format is YAML with whitespace", func(t *testing.T) {
		assert.True(t, IsValidOutputFormat("   YAML  "))
	})
	t.Run("Fail to return true if the input format is not supported", func(t *testing.T) {
		assert.False(t, IsValidOutputFormat("toml"))
	})
}
